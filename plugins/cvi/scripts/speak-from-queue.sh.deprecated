#!/bin/bash

# DEPRECATED: 2026-02-11
# Replaced by Reporter Agent architecture
# This script is no longer used - kept for reference only
#
# Original purpose:
# CVI Speak From Queue - PostToolUse hook handler
# Runs outside sandbox, reads queue file and plays audio.
# Called by PostToolUse hook with matcher="Skill".
# Filters on skill="cvi:speak"; exits immediately for other skills.

# Extract skill name from stdin (use jq if available, fallback to regex)
INPUT=$(cat)
if command -v jq &> /dev/null; then
    SKILL_NAME=$(echo "$INPUT" | jq -r '.tool_input.skill // empty' 2>/dev/null)
fi
# Fallback: regex extraction if jq unavailable or returned empty
if [ -z "$SKILL_NAME" ]; then
    SKILL_NAME=$(echo "$INPUT" | grep -o '"skill"[[:space:]]*:[[:space:]]*"[^"]*"' | head -1 | sed 's/.*"skill"[[:space:]]*:[[:space:]]*"//' | sed 's/"//')
fi

# Only process cvi:speak
[ "$SKILL_NAME" != "cvi:speak" ] && exit 0

# Claim queue file via rename to prevent read/write overlap with speak.sh
QUEUE_FILE="$HOME/.cvi/speak-queue"
TEMP_QUEUE="${QUEUE_FILE}.$$"

# No queue file = nothing to speak (e.g. CVI disabled or write failed)
[ ! -f "$QUEUE_FILE" ] && exit 0

# Queue file exists - attempt atomic claim
if ! mv "$QUEUE_FILE" "$TEMP_QUEUE" 2>/dev/null; then
    echo "Error: Failed to claim queue file $QUEUE_FILE" >&2
    exit 1
fi

if ! MSG=$(cat "$TEMP_QUEUE" 2>/dev/null); then
    echo "Error: Failed to read temp queue file $TEMP_QUEUE" >&2
    rm -f "$TEMP_QUEUE"
    exit 1
fi
rm -f "$TEMP_QUEUE" || echo "Warning: Failed to clean up $TEMP_QUEUE" >&2
[ -z "$MSG" ] && exit 0

# Load CVI config
CONFIG_FILE="$HOME/.cvi/config"
if [ -f "$CONFIG_FILE" ]; then
    SPEECH_RATE=$(grep "^SPEECH_RATE=" "$CONFIG_FILE" | cut -d'=' -f2)
    VOICE_LANG=$(grep "^VOICE_LANG=" "$CONFIG_FILE" | cut -d'=' -f2)
    VOICE_EN=$(grep "^VOICE_EN=" "$CONFIG_FILE" | cut -d'=' -f2)
    VOICE_JA=$(grep "^VOICE_JA=" "$CONFIG_FILE" | cut -d'=' -f2)
    AUTO_DETECT_LANG=$(grep "^AUTO_DETECT_LANG=" "$CONFIG_FILE" | cut -d'=' -f2)
    VOICE_MODE=$(grep "^VOICE_MODE=" "$CONFIG_FILE" | cut -d'=' -f2)
    VOICE_FIXED=$(grep "^VOICE_FIXED=" "$CONFIG_FILE" | cut -d'=' -f2)
fi

SPEECH_RATE=${SPEECH_RATE:-200}
VOICE_LANG=${VOICE_LANG:-ja}
VOICE_EN=${VOICE_EN:-Samantha}
VOICE_JA=${VOICE_JA:-system}
AUTO_DETECT_LANG=${AUTO_DETECT_LANG:-false}
VOICE_MODE=${VOICE_MODE:-auto}

# Validate SPEECH_RATE is numeric
if ! [[ "$SPEECH_RATE" =~ ^[0-9]+$ ]]; then
    echo "Warning: Invalid SPEECH_RATE='$SPEECH_RATE' in config, using default 200" >&2
    SPEECH_RATE=200
fi

# Detect language if AUTO_DETECT_LANG is enabled, otherwise use configured VOICE_LANG
if [ "$AUTO_DETECT_LANG" = "true" ]; then
    if echo "$MSG" | grep -q '[ぁ-んァ-ヶー一-龠]'; then
        DETECTED_LANG="ja"
    else
        DETECTED_LANG="en"
    fi
else
    DETECTED_LANG="$VOICE_LANG"
fi

# Select voice based on mode and detected language
if [ "$VOICE_MODE" = "fixed" ] && [ -n "$VOICE_FIXED" ]; then
    SELECTED_VOICE="$VOICE_FIXED"
elif [ "$DETECTED_LANG" = "ja" ]; then
    SELECTED_VOICE="$VOICE_JA"
else
    SELECTED_VOICE="$VOICE_EN"
fi

# Sanitize message (escape backslashes, double quotes, and replace newlines with spaces)
SAFE_MSG=$(printf '%s' "$MSG" | sed 's/\\/\\\\/g; s/"/\\"/g' | tr '\n' ' ')

# Execute audio (runs outside sandbox, so osascript/afplay/say are not blocked)
SESSION_DIR=$(basename "$(pwd)")
osascript -e "display notification \"$SAFE_MSG\" with title \"ClaudeCode ($SESSION_DIR) Task Done\"" 2>/dev/null &
afplay /System/Library/Sounds/Glass.aiff 2>/dev/null &
if [ "$SELECTED_VOICE" = "system" ]; then
    say -r "$SPEECH_RATE" -- "$SAFE_MSG" 2>/dev/null &
else
    say -v "$SELECTED_VOICE" -r "$SPEECH_RATE" -- "$SAFE_MSG" 2>/dev/null &
fi
SAY_PID=$!

# Wait for say to finish and check for errors (say is the critical command)
wait "$SAY_PID" 2>/dev/null
SAY_EXIT=$?
if [ $SAY_EXIT -ne 0 ]; then
    echo "Warning: say command failed (exit $SAY_EXIT), voice='${SELECTED_VOICE}', rate='${SPEECH_RATE}'" >&2
fi
